<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Trace</title>
  
  <subtitle>即便是喧嚣不止的时日，也想为失去笑容的你，献上我所能想象到的最耀眼的明天。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-23T09:32:50.183Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Trace</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>现代开关电源技术</title>
    <link href="http://example.com/2025/09/23/%E7%8E%B0%E4%BB%A3%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2025/09/23/%E7%8E%B0%E4%BB%A3%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90%E6%8A%80%E6%9C%AF/</id>
    <published>2025-09-23T09:32:50.000Z</published>
    <updated>2025-09-23T09:32:50.183Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>江科大STM32零基础学习</title>
    <link href="http://example.com/2025/09/22/%E6%B1%9F%E7%A7%91%E5%A4%A7STM32%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2025/09/22/%E6%B1%9F%E7%A7%91%E5%A4%A7STM32%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-09-22T08:39:08.000Z</published>
    <updated>2025-09-23T09:31:09.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="（一）驱动GPIO"><a href="#（一）驱动GPIO" class="headerlink" title="（一）驱动GPIO"></a>（一）驱动GPIO</h1><p>GPIO（General Purpose Input&#x2F;Output）是 STM32 最常用的功能模块。</p><p>GPIO具有输入和输出两种模式，每种模式又具备四种工作模式，因此GPIO共有八种工作模式。输入模式可以配置为分为上拉输入、下拉输入、浮空输入和模拟输入；输出模式可以配置为开漏输出、推挽输出、复用推挽输出和复用开漏输出。下表是八种工作模式的介绍：</p><table><thead><tr><th>模式名称</th><th>性质</th><th>特征</th><th>对应代码示例</th></tr></thead><tbody><tr><td>上拉输入</td><td>输入</td><td>内部上拉电阻，默认高电平，适合检测开关&#x2F;按键</td><td><code>GPIO_Mode_IPU</code></td></tr><tr><td>下拉输入</td><td>输入</td><td>内部下拉电阻，默认低电平，适合检测开关&#x2F;按键</td><td><code>GPIO_Mode_IPD</code></td></tr><tr><td>浮空输入</td><td>输入</td><td>无上下拉，状态不确定，需外部电路稳定电平</td><td><code>GPIO_Mode_IN_FLOATING</code></td></tr><tr><td>模拟输入</td><td>输入</td><td>输入到 ADC，功耗低，适合模拟信号采集</td><td><code>GPIO_Mode_AIN</code></td></tr><tr><td>推挽输出</td><td>输出</td><td>可输出高低电平，驱动能力强</td><td><code>GPIO_Mode_Out_PP</code></td></tr><tr><td>开漏输出</td><td>输出</td><td>只能输出低电平，高电平需外接上拉电阻，可用于I²C总线</td><td><code>GPIO_Mode_Out_OD</code></td></tr><tr><td>复用推挽输出</td><td>输出</td><td>用于片上外设（USART、SPI等），高速高驱动</td><td><code>GPIO_Mode_AF_PP</code></td></tr><tr><td>复用开漏输出</td><td>输出</td><td>与总线共享，可与外设共用，如I²C</td><td><code>GPIO_Mode_AF_OD</code></td></tr></tbody></table><h2 id="GPIO驱动流程（标准库方式）"><a href="#GPIO驱动流程（标准库方式）" class="headerlink" title="GPIO驱动流程（标准库方式）"></a>GPIO驱动流程（标准库方式）</h2><p>在使用标准库配置GPIO的工作模式时，需要先执行两个步骤：先初始化时钟，在配置对应的GPIO的工作模式</p><h5 id="驱动代码"><a href="#驱动代码" class="headerlink" title="驱动代码"></a>驱动代码</h5><ol><li><p><strong>使能时钟</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使能 GPIOC 外设时钟，否则不能操作 GPIOC</span></span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);　<span class="comment">//使能GPIOC所在的时钟</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置GPIO结构体（以PC13为例）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 定义一个 GPIO 初始化结构体，用于配置 GPIO 引脚属性</span></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 选择 PC13 引脚（通常在开发板上接 LED）</span></span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 设置GPIO的工作模式</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_PP;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 设置 GPIO 输出速度为 50MHz（输出切换速度）</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 调用库函数完成 GPIO 初始化</span></span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-GPIO输出模式"><a href="#1-GPIO输出模式" class="headerlink" title="1.GPIO输出模式"></a>1.GPIO输出模式</h2><p>GPIO输入模式可以分为推挽输出、开漏输出以及复用推挽输出和复用开漏输出，推挽输出的驱动能力较强，可以输出高低电平，而开漏输出只能输出低电平，设置为高电平时为高阻态，因此开漏输出可以输出更高的电压，只需在外部接上拉电阻即可。</p><h3 id="可驱动的外设"><a href="#可驱动的外设" class="headerlink" title="可驱动的外设"></a>可驱动的外设</h3><h4 id="LED："><a href="#LED：" class="headerlink" title="LED："></a>LED：</h4><p>常用推挽输出，直接点亮或熄灭 LED。</p><h5 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 LED 所在的 GPIO 引脚</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点亮 LED</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_On</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对 PC13 输出低电平，由于 LED 是低电平点亮，所以这里用 Reset</span></span><br><span class="line">    GPIO_ResetBits(GPIOC, GPIO_Pin_13);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 熄灭 LED</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Off</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对 PC13 输出高电平，使 LED 熄灭</span></span><br><span class="line">    GPIO_SetBits(GPIOC, GPIO_Pin_13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="蜂鸣器："><a href="#蜂鸣器：" class="headerlink" title="蜂鸣器："></a>蜂鸣器：</h4><h5 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开蜂鸣器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_On</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对 PB5 输出高电平，驱动蜂鸣器响</span></span><br><span class="line">    GPIO_SetBits(GPIOB, GPIO_Pin_5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭蜂鸣器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Off</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 对 PB5 输出低电平，关闭蜂鸣器</span></span><br><span class="line">    GPIO_ResetBits(GPIOB, GPIO_Pin_5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-GPIO输入模式"><a href="#2-GPIO输入模式" class="headerlink" title="2.GPIO输入模式"></a>2.GPIO输入模式</h2><p>GPIO的输入模式可以分为上拉输入、下拉输入、浮空输入和模拟输入，其中模拟输入用于检测端口的ADC数值，并将模拟数值转换为数字量给出，而上拉、下拉和浮空输入则是检测端口的高低电平，高电平为1，低电平为0。上拉输入默认输入为高电平，下拉输入默认输入为低电平。</p><h3 id="可驱动的外设-1"><a href="#可驱动的外设-1" class="headerlink" title="可驱动的外设"></a>可驱动的外设</h3><h4 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h4><p>常见的输入设备，按下导通，松手断开，由于按键内部使用的是机械式弹簧来进行通断的，所以按下和松手时会有一连串的抖动。</p><h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化按键 GPIO</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 使能 GPIOA 外设时钟（因为按键接在 PA0）</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 定义一个 GPIO 初始化结构体</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 选择按键所在的引脚，这里是 PA0</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 配置为上拉输入模式（内部上拉电阻，默认高电平）</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 输入模式下，GPIO_Speed 参数无效，但必须赋值，习惯性填 50MHz</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 调用库函数，完成 GPIOA 的初始化</span></span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传感器模块"><a href="#传感器模块" class="headerlink" title="传感器模块"></a>传感器模块</h4><h4 id="相关驱动函数"><a href="#相关驱动函数" class="headerlink" title="相关驱动函数"></a>相关驱动函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;（一）驱动GPIO&quot;&gt;&lt;a href=&quot;#（一）驱动GPIO&quot; class=&quot;headerlink&quot; title=&quot;（一）驱动GPIO&quot;&gt;&lt;/a&gt;（一）驱动GPIO&lt;/h1&gt;&lt;p&gt;GPIO（General Purpose Input&amp;#x2F;Output）是 S</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NFC产品设计</title>
    <link href="http://example.com/2024/06/27/NFC%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2024/06/27/NFC%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-06-27T15:13:47.000Z</published>
    <updated>2024-06-27T15:16:12.199Z</updated>
    
    <content type="html"><![CDATA[<p>根据芯片手册计算出线圈所需要的电感值，下列列表为参考</p><table><thead><tr><th align="center">C(pF)</th><th align="center">Lant(uH)@13.56MHz</th><th align="center">建议值(uH)</th></tr></thead><tbody><tr><td align="center">28.5</td><td align="center">4.5~4.7</td><td align="center">4.6</td></tr><tr><td align="center">50</td><td align="center">2.5~2.7</td><td align="center">2.6</td></tr><tr><td align="center">97</td><td align="center">1.2~1.4</td><td align="center">1.3</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;根据芯片手册计算出线圈所需要的电感值，下列列表为参考&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;C(pF)&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Lant(uH)@13.56MHz&lt;/th&gt;
&lt;th align=&quot;ce</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Buck电路的设计与布局</title>
    <link href="http://example.com/2024/05/15/Buck%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2024/05/15/Buck%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%B8%83%E5%B1%80/</id>
    <published>2024-05-15T15:11:01.000Z</published>
    <updated>2024-06-05T12:44:06.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自恢复保险丝介绍"><a href="#自恢复保险丝介绍" class="headerlink" title="自恢复保险丝介绍"></a>自恢复保险丝介绍</h2><p>自恢复保险丝是一种过流电子保护元件，采用高分子有机聚合物在高压、高温，硫化反应的条件下，掺加导电粒子材料后，经过特殊的工艺加工而成。传统保险丝过流保护，仅能保护一次，烧断了需更换，而自恢复保险丝具有过流过热保护，自动恢复双重功能。</p><p><strong>1.工作原理</strong></p><p>　　自恢复保险丝是由经过特殊处理的聚合树脂(Polymer)及分布，在里面的导电粒子(Carbon Black)组成。在正常操作下，聚合树脂紧密地将导电粒子，束缚在结晶状的结构外，构成链状导电电通路，此时的自恢复保险丝为低阻状态(a)，线路上流经自恢复保险丝的电流所产生的热能小，不会改变晶体结构。</p><p>　　当线路发生短路或过载时，流经自恢复保险丝的大电流，产生的热量使聚合树脂融化，体积迅速增长，形成高阻状态(b)，工作电流迅速减小，从而对电路进行限制和保护。</p><p>　　当故障排除后，自恢复保险丝重新冷却结晶，体积收缩，导电粒子重新形成导电通路，自恢复保险丝恢复为低阻状态，从而完成对电路的保护，无须人工更换。</p><p><strong>2.动作原理</strong></p><p>　　自恢复保险丝的动作原理是一种能量的动态平衡，流过自恢复保险丝的电流，由于电流热效应的关系，产生一定程度的热量(自恢复保险丝都存在阻值)，产生的热全部或部分散发到环境中，而没有散发出去的热便会提高自恢复保险丝元件的温度。</p><p>　　正常工作时的温度较低，产生的热和散发的热达到平衡。</p><p>　　自恢复保险丝元件处于低阻状态，自恢复保险丝不动作，当流过自恢复保险丝元件的电流，增加或环境温度升高，但如果达到产生的热和散发的热的平衡时，自恢复保险丝仍不动作。</p><p>　　当电流或环境温度再提高时，自恢复保险丝会达到较高的温度。</p><p>　　若此时电流或环境温度，继续再增加，产生的热量，会大于散发出去的热量，使得自恢复保险丝元件温度骤增，在此阶段，很小的温度变化会造成阻值的大幅提高，这时自恢复保险丝元件处于高阻保护状态，阻抗的增加限制了电流，电流在很短时间内急剧下降，从而保护电路设备免受损坏，只要施加的电压所产生的热量足够自恢复保险丝元件散发出的热量，处于变化状态下的自恢复保险丝元件便可以一直处于动作状态(高阻)。</p><p>　　当施加的电压消失时，自恢复保险丝便可以自动恢复了。</p><p>​<strong>3.保险丝参数介绍</strong></p><p>• Ihold：维持电流</p><p>• Itrip：规定电流下的最大动作时间；</p><p>• Vmax：可承受的最大电压</p><p>• Imax：可承受的最大电流</p><p>• Pd：高阻状态的稳压功耗</p><p>• R：一定温度下测得的零功率电阻</p><p>• R1max：经动作或回焊一小时后在室温下所测得的最大电阻值</p><p>• 环境温度：PTC周围静止空气的温度</p><p>• 最大工作环境温度：PTC安全工作的最高环境温度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自恢复保险丝介绍&quot;&gt;&lt;a href=&quot;#自恢复保险丝介绍&quot; class=&quot;headerlink&quot; title=&quot;自恢复保险丝介绍&quot;&gt;&lt;/a&gt;自恢复保险丝介绍&lt;/h2&gt;&lt;p&gt;自恢复保险丝是一种过流电子保护元件，采用高分子有机聚合物在高压、高温，硫化反应的条件下，掺加</summary>
      
    
    
    
    
    <category term="硬件知识" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯嵌入式</title>
    <link href="http://example.com/2024/04/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    <id>http://example.com/2024/04/11/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%B5%8C%E5%85%A5%E5%BC%8F/</id>
    <published>2024-04-11T11:49:15.000Z</published>
    <updated>2024-04-11T11:56:45.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STM32G431模块"><a href="#STM32G431模块" class="headerlink" title="STM32G431模块"></a>STM32G431模块</h1><h4 id="LED模块："><a href="#LED模块：" class="headerlink" title="LED模块："></a>LED模块：</h4><p>首先，在Cube MX里面配置PC8-15、PD2引脚，均配置为Output模式，输出电平为High，推挽输出模式（Output Push Pull）。</p><p><img src="https://img.gsimg.top/2024/04/11/w1a3ow.png" alt="image-20240411142511448"></p><h6 id="先点个灯吧，点灯函数："><a href="#先点个灯吧，点灯函数：" class="headerlink" title="先点个灯吧，点灯函数："></a>先点个灯吧，点灯函数：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Led_disp(uint8_t dsled)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,GPIO_PIN_All,GPIO_PIN_SET); //先将PC全部端口致置一</span><br><span class="line">HAL_GPIO_WritePin(GPIOC,dsled&lt;&lt;8,GPIO_PIN_RESET);//</span><br><span class="line">HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_SET);//开启PD2引脚，将PC端口数据存储进入</span><br><span class="line">HAL_GPIO_WritePin(GPIOD,GPIO_PIN_2,GPIO_PIN_RESET);//关闭PD2引脚，使得不影响LCD屏幕使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="若是想要一个灯闪烁，而其他的长亮，则需要使用函数："><a href="#若是想要一个灯闪烁，而其他的长亮，则需要使用函数：" class="headerlink" title="若是想要一个灯闪烁，而其他的长亮，则需要使用函数："></a>若是想要一个灯闪烁，而其他的长亮，则需要使用函数：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">uint8_t Led_sta = 0xff;//先定义一个外部变量，该变量存储初始状态值</span><br><span class="line"></span><br><span class="line">void Led_chg(uint8_t num,unit8_t sta)//num存储的是需要点亮的LED位置，sta则是LED的状态</span><br><span class="line">&#123;</span><br><span class="line">uint8_t pos = 0x01&lt;&lt;(num-1)</span><br><span class="line">Led_sta = (Led_sta &amp; (~pos))|(pos * sta);</span><br><span class="line">Led_disp(Led_sta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">Led_sta(1,1);</span><br><span class="line">HAL_Delay(500);</span><br><span class="line">Led_sta(1,0)</span><br><span class="line">HAL_Delay(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这些就是LED模块的使用方法了。</p><h4 id="按键模块："><a href="#按键模块：" class="headerlink" title="按键模块："></a>按键模块：</h4><p>先在Cube MX里面配置PA0，PB0-2，配置为GPIO_Input模式，默认上拉(Pull-up)。</p><p>其中引脚与板子上的KEY1-4对应关系如下</p><table><thead><tr><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><strong>Key1</strong></td><td align="center"><strong>PB0</strong></td></tr><tr><td align="center"><strong>KEY2</strong></td><td align="center"><strong>PB1</strong></td></tr><tr><td align="center"><strong>KEY3</strong></td><td align="center"><strong>PB2</strong></td></tr><tr><td align="center"><strong>KEY4</strong></td><td align="center"><strong>PA0</strong></td></tr></tbody></table><p><img src="https://img.gsimg.top/2024/04/11/w4yz29.png" alt="image-20240411151301151"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint8_t Key_read()//按键读取函数，当按键被按下则返回对应的按键编号</span><br><span class="line">&#123;</span><br><span class="line">if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_0) == 0) return 1;</span><br><span class="line">else if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_1) == 0) return 2;</span><br><span class="line">else if(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_2) == 0) return 3;</span><br><span class="line">else if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0) == 0) return 4;</span><br><span class="line">else return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为按键需要消抖，常见的方法是在判断按键被按下后延时一段时间再检测按键是否被按下，因为涉及到延时，所以有些许不便，本篇采用定时器中断的方法来消抖。</p><p>首先，在Cube MX里面配置基本定时器TIM6。</p><p><img src="https://img.gsimg.top/2024/04/11/w1kc4u.png" alt="image-20240411152834721"></p><p>因为使用的是定时器中断，所以不要忘记把NVIC打开</p><p><img src="https://img.gsimg.top/2024/04/11/w4hlbt.png" alt="image-20240411153020798"></p><p>其次，需要在主程序里面启动TIM6，启动函数为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim6);</span><br></pre></td></tr></table></figure><p>最后，要在主程序末尾添加中断回调函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</span><br><span class="line">&#123;</span><br><span class="line">if(htim-&gt;Instance == TIM6)//判断是TIM6定时器引起的中断</span><br><span class="line">&#123;</span><br><span class="line">//放置需要在中断中执行的函数</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="按键判断函数（长按按下后识别）"><a href="#按键判断函数（长按按下后识别）" class="headerlink" title="按键判断函数（长按按下后识别）"></a>按键判断函数（长按按下后识别）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">struct KEY //先定义一个结构体</span><br><span class="line">&#123;</span><br><span class="line">uint8_t press;//检测是否被按下</span><br><span class="line">uint16_t age;//开始计时</span><br><span class="line"></span><br><span class="line">uint8_t short_flag;//短按标志位</span><br><span class="line">uint8_t long_flag;//长按标志位</span><br><span class="line"></span><br><span class="line">uint8_t ageEN;//双击判断标志位</span><br><span class="line">uint16_t double_age//双击间隔时间计时</span><br><span class="line">uint8_t double_flag;//双击标志位</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//因为有4个按键，而从0开始计数，所以定义5个</span><br><span class="line">struct KEY key[5] = &#123;0,0,0,0,0&#125;;</span><br><span class="line"></span><br><span class="line">void Key_ser()</span><br><span class="line">&#123;</span><br><span class="line">uint8_t Key_num = Key_read();</span><br><span class="line">if(Key_num != 0)</span><br><span class="line">&#123;</span><br><span class="line">key[Key_num].age++;</span><br><span class="line">if(key[Key_num].age == 2) key[Key_num].press = 1;</span><br><span class="line">&#125;</span><br><span class="line">else for(int i = 0;i&lt;4;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(key[i].age &gt; 99)</span><br><span class="line">key[i].long_flag = 1;</span><br><span class="line">if(key[i].press == 1 &amp;&amp; key[i].long_flag != 1)</span><br><span class="line">key[i].short_flag = 1;</span><br><span class="line"></span><br><span class="line">key[i].press = 0;</span><br><span class="line">key[i].age = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Key_ser()//按键判断函数</span><br><span class="line">&#123;</span><br><span class="line">uint8_t Key_num = Key_read();//读取被按下的按键的编号</span><br><span class="line">if(Key_num != 0)//如果按键被按下</span><br><span class="line">&#123;</span><br><span class="line">//对应编号的按键开始对按下时间进行计时</span><br><span class="line">key[Key_num].age++;</span><br><span class="line">//对应编号的按键按下标志位置一</span><br><span class="line">if(key[Key_num].age == 2) key[Key_num].press = 1;</span><br><span class="line">&#125;</span><br><span class="line">//循环检测1-4号按键的标志位</span><br><span class="line">else for(int i = 1;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">//如果按键被按下且按下时间超过99*10ms，则识别为长按。</span><br><span class="line">if(key[i].press == 1 &amp;&amp; key[i].age &gt; 99)</span><br><span class="line">key[i].long_flag = 1;</span><br><span class="line">//如果按键被按下且长按标志位不为1，则识别为短按。</span><br><span class="line">if(key[i].press == 1 &amp;&amp; key[i].long_flag != 1)</span><br><span class="line">key[i].short_flag = 1;</span><br><span class="line">//将按下标志位以及按下时间计时清零。</span><br><span class="line">key[i].press = 0;</span><br><span class="line">key[i].age = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//在主函数里面判断后，需要将对应标志位清零。</span><br><span class="line">if(key[1].long_flag == 1)</span><br><span class="line">&#123;</span><br><span class="line">Led_sta = 0xff;</span><br><span class="line">//记得在判断函数里面将对应标志位清零。</span><br><span class="line">key[1].long_flag = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="按键判断函数（按住超过时间即可被识别为长按）"><a href="#按键判断函数（按住超过时间即可被识别为长按）" class="headerlink" title="按键判断函数（按住超过时间即可被识别为长按）"></a>按键判断函数（按住超过时间即可被识别为长按）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Key_ser()</span><br><span class="line">&#123;</span><br><span class="line">uint8_t Key_num = Key_read();</span><br><span class="line">if(Key_num != 0)</span><br><span class="line">&#123;</span><br><span class="line">key[Key_num].age++;</span><br><span class="line">if(key[Key_num].age == 2) key[Key_num].press = 1;</span><br><span class="line">&#125;</span><br><span class="line">else for(int i = 1;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(key[i].press == 1 &amp;&amp; key[i].long_flag != 1)</span><br><span class="line">key[i].short_flag = 1;</span><br><span class="line"></span><br><span class="line">key[i].press = 0;</span><br><span class="line">key[i].age = 0;</span><br><span class="line">&#125;</span><br><span class="line">//与上方函数不同的地方，将判断长按的函数从for循环里面拿出来了</span><br><span class="line">if(key[Key_num].press == 1 &amp;&amp; key[Key_num].age &gt; 99)</span><br><span class="line">key[Key_num].long_flag = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="按键判断函数（双击）"><a href="#按键判断函数（双击）" class="headerlink" title="按键判断函数（双击）"></a>按键判断函数（双击）</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void Key_ser()</span><br><span class="line">&#123;</span><br><span class="line">uint8_t Key_num = Key_read();</span><br><span class="line">if(Key_num != 0)</span><br><span class="line">&#123;</span><br><span class="line">key[Key_num].age++;</span><br><span class="line">if(key[Key_num].age == 2) key[Key_num].press = 1;</span><br><span class="line">&#125;</span><br><span class="line">else for(int i = 1;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">//第二次按下后开始判断，如果此时双击标志位仍然为一，则判断为双击。</span><br><span class="line">if(key[i].press == 1 &amp;&amp; key[i].ageEN == 1)</span><br><span class="line">&#123;</span><br><span class="line">key[i].double_flag = 1;</span><br><span class="line">key[i].press = 0;</span><br><span class="line">key[i].ageEN = 0;</span><br><span class="line">&#125;</span><br><span class="line">//如果按键被按下，且长按标志位为零，则将双击判断标志位置一</span><br><span class="line">if(key[i].press == 1 &amp;&amp; key[i].long_flag == 0) </span><br><span class="line">        key[i].ageEN = 1;</span><br><span class="line">        //如果双击判断标志位为一，则开始双击间隔计时</span><br><span class="line">if(key[i].ageEN == 1) key[i].double_age++;</span><br><span class="line">//如果双击判断标志位为一，且双击间隔计时超过20*10ms，则判断为短按。</span><br><span class="line">if(key[i].ageEN == 1 &amp;&amp; key[i].double_age &gt; 20)</span><br><span class="line">&#123;</span><br><span class="line">key[i].short_flag = 1;</span><br><span class="line">key[i].double_age = 0;</span><br><span class="line">key[i].ageEN = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key[i].press = 0;</span><br><span class="line">key[i].age = 0;</span><br><span class="line">&#125;</span><br><span class="line">if(key[Key_num].press == 1 &amp;&amp; key[Key_num].age &gt; 99)</span><br><span class="line">key[Key_num].long_flag = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PWM产生"><a href="#PWM产生" class="headerlink" title="PWM产生"></a>PWM产生</h4><p>Cube MX里面可以通过配置计时器来翻转IO口输出的电平，以达到产生PWM的作用。</p><p>目前可以使用产生PWM的只有通道CH1和CH2，需要在Cube MX里面进行如下配置，以PA1、TIM2_CH2为例。</p><p><img src="https://img.gsimg.top/2024/04/11/w3dqn4.png" alt="image-20240411165859951"></p><p><img src="https://img.gsimg.top/2024/04/11/w3354p.png" alt="image-20240411170033689"></p><p>生成代码后，需要先使能TIM2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htim2,TIM_CHANNEL_2);</span><br></pre></td></tr></table></figure><p>如果需要在程序中更改PWM产生的频率或者占空比，则可以通过更改计数器(AUTORELOAD)的值以及Pulse来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将PWM设置为</span><br><span class="line"></span><br><span class="line">//设置计数器的值</span><br><span class="line">__HAL_TIM_SET_AUTORELOAD(&amp;htim2,5000-1);</span><br><span class="line">//设置Pulse的值</span><br><span class="line">__HAL_TIM_SetCompare(&amp;htim2,TIM_CHANNEL_2,200);</span><br></pre></td></tr></table></figure><h4 id="PWM测量"><a href="#PWM测量" class="headerlink" title="PWM测量"></a>PWM测量</h4><p>通过STM32的输入捕获功能，可以简单测量出输入引脚的PWM的占空比以及频率。</p><p><img src="https://img.gsimg.top/2024/04/11/w3tn23.png" alt="image-20240411172848539"></p><p><img src="https://img.gsimg.top/2024/04/11/w3y2sr.png" alt="image-20240411172947341"></p><p>配置完成之后，需要在主程序里面把定时器打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_IC_Start(&amp;htim15,TIM_CHANNEL_1);</span><br><span class="line">HAL_TIM_IC_Start(&amp;htim15,TIM_CHANNEL_2);</span><br><span class="line"></span><br><span class="line">//配置好之后，需要定义两个变量来存放测到的频率以及占空比</span><br><span class="line">float frq1,duty1;</span><br><span class="line">//频率的计算为主频÷分频÷测量得到的值</span><br><span class="line">frq1 = 10000000.0f / (HAL_TIM_ReadCapturedValue(&amp;htim15,TIM_CHANNEL_1)+1);</span><br><span class="line">duty1 = (HAL_TIM_ReadCapturedValue(&amp;htim15,TIM_CHANNEL_2)+1) / (HAL_TIM_ReadCapturedValue(&amp;htim15,TIM_CHANNEL_1)+1) * 100.0f;</span><br></pre></td></tr></table></figure><h4 id="ADC测量模拟量电压"><a href="#ADC测量模拟量电压" class="headerlink" title="ADC测量模拟量电压"></a>ADC测量模拟量电压</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;STM32G431模块&quot;&gt;&lt;a href=&quot;#STM32G431模块&quot; class=&quot;headerlink&quot; title=&quot;STM32G431模块&quot;&gt;&lt;/a&gt;STM32G431模块&lt;/h1&gt;&lt;h4 id=&quot;LED模块：&quot;&gt;&lt;a href=&quot;#LED模块：&quot; cla</summary>
      
    
    
    
    
    <category term="Study" scheme="http://example.com/tags/Study/"/>
    
  </entry>
  
  <entry>
    <title>灯光画</title>
    <link href="http://example.com/2023/11/19/%E7%81%AF%E5%85%89%E7%94%BB/"/>
    <id>http://example.com/2023/11/19/%E7%81%AF%E5%85%89%E7%94%BB/</id>
    <published>2023-11-19T03:25:25.000Z</published>
    <updated>2024-02-24T13:42:24.055Z</updated>
    
    <content type="html"><![CDATA[<p>在九月份无意间在B站看到了灯光画之后，就萌生出了DIY一个的念头。当时B站视频里的灯光画大多都是使用USB-A接口，或者使用的电池盒来供电，并且购买的灯带，这样对于没有焊接经验的人来说确实方便。但是我却想进行一定的改装，将它变成Type-C接口，来适配大多数的情况。</p><span id="more"></span><p>于是带着这样的想法，灯光画的第一版艰难的实现了。学校里面的打印店几乎没有能够打印菲林纸的，使用的25mm的灯丝来发亮，同时加了开关以及Type-C口来使灯丝发亮，效果也出奇的不错。</p><p><img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/Light/Light1.jpg?raw=true" alt="1"></p><center>第二版示例图</center><p>但是第一版也暴露出许多问题来，最大的问题就是朋友吐槽虽然确实可以Type-C供电了，但是还是不够方便，于是我突然就有了增加一个充电电路，以及可充电的锂电池的想法，于是在不断的拖延中，托更的主要问题还是买错元器件了，于是耽误了十几天，但是终于在11月19号完成了。</p><p>第二版的灯光画新增加了LED驱动电路，因为关于这部分的资料我在网上并没有找到太多，所以就根据立创商城的查找功能找到了一个合适的驱动芯片，同时根据datesheet设计了一个电路，所幸能够驱动起来。在此基础上，将灯由发光灯丝改为了5730灯珠。同时增加了TP4056充电保护电路。</p><p><img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/Light/Light2.png?raw=ture" alt="2"></p><center>灯光画原理图</center><p>第一次焊接时发现白光和蓝光区别挺大，并且白光的色温越高越暖。因为我的底画是蓝色色调的，就想着焊一些蓝光进去，但是效果有点吓人。所以就换掉了，改为3000K色温的白光。</p><p>不出意外这应该是最后一版了，接下来恐怕是不会再进行改版。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在九月份无意间在B站看到了灯光画之后，就萌生出了DIY一个的念头。当时B站视频里的灯光画大多都是使用USB-A接口，或者使用的电池盒来供电，并且购买的灯带，这样对于没有焊接经验的人来说确实方便。但是我却想进行一定的改装，将它变成Type-C接口，来适配大多数的情况。&lt;/p&gt;</summary>
    
    
    
    
    <category term="个人DIY" scheme="http://example.com/tags/%E4%B8%AA%E4%BA%BADIY/"/>
    
  </entry>
  
  <entry>
    <title>智能车手册-持续更新中</title>
    <link href="http://example.com/2023/09/18/%E6%99%BA%E8%83%BD%E8%BD%A6%E6%89%8B%E5%86%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/"/>
    <id>http://example.com/2023/09/18/%E6%99%BA%E8%83%BD%E8%BD%A6%E6%89%8B%E5%86%8C-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/</id>
    <published>2023-09-18T02:23:35.000Z</published>
    <updated>2025-09-23T10:20:41.092Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>此篇文章由Trace以及其队友郑鹤联合整理编写。其中，硬件部分由Trace整理编写，软件相关则由郑鹤负责。</p><p><img src="https://img.gsimg.top/2024/04/21/10f2mjx.jpg" alt="d396a31b37615948a0edb12f569e606"></p><p><img src="https://img.gsimg.top/2024/04/21/10gba9r.jpg" alt="184fae8159266018719991dfe6f23d8"></p><p><img src="https://img.gsimg.top/2024/04/21/10fx9q5.jpg"></p><p><strong>先贴几张我们比赛时候车车的帅照。</strong></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在接触智能车并且在硬件上有些心得之后，就开始有想法去写一篇硬件手册去传承下去，来做为真正的实验室传承，但是碍于种种原因始终未能做到。本来在一次聚餐之后，买了一些蜜雪冰城的奶茶之后抽奖抽到了一个比较大的笔记本，原本想用这个来作为硬件的传承手册。沉思之后想了想还是算了吧，虽然实体书可以让你在携带它时任何时候都能够翻开去看，但是终究不如以博客的形式保存起来。</p><p>做这个并没有带有什么目的，仅仅是想把我、我们在硬件上面走的路给传下去，为了让后来者能够避免掉进我们所走的路上的坑，这些仅仅是经验所书写的，希望后来者有寻根到底的思想，因为经验可能也意味着错误，不能尽信。我们只是将我们所知道的一些信息进行汇总，而很有可能我们得到的就是错误的，我们确认为是正确的写了上去，所以希望你们保留批判思维。</p><p>学习硬件是一个奇妙的旅程，你能够看到你自己设计的物品编程实物，并且发挥着它的作用，这里面的欣喜是难以形容的。但这旅程中也会有令人灰心丧气的风景，你满怀期待的去验证焊接完的板子，却怎么也找不到原因。或许是你的原理图从一开始就是错的，也或许，你的电流回路有问题。这些问题总是很玄学，找到后也没办法去及时的分享，使得重复造轮子的事情出现。而这也是我主张写总结的原因，不要重复造轮子。</p><p>然而或许这就是硬件学习发展的规律，你在成长期间，最开始却总是从重复造轮子开始的。</p><p>对于智能车竞赛使用的PCB板来说，连好线就能使用，但是很多知识你并不了解，硬件也并不单指画PCB板。</p><p><strong>（2023&#x2F;7&#x2F;7)推荐一个软件：半导小芯，这个软件挺好用的，能够查看很多常用的元器件的参数以及芯片手册。</strong></p><p>对应的电脑端的网站为：<a href="http://www.semiee.com/">半导小芯-芯片查询工具_芯片替代查询_数据手册查询_规格书查询_datasheet查询_IC查询 (semiee.com)</a></p><h2 id="一、认识元器件"><a href="#一、认识元器件" class="headerlink" title="一、认识元器件"></a>一、认识元器件</h2><p>或许你看到这个会不屑一顾。哼，认识元器件？我不是早就认识了吗？其实并不然。永远不要说你认识一个元器件，保持住最初接触硬件的好奇心。要知道，即便是早就发行的NE555时钟芯片，在现在仍然被开发着新的用途。</p><h3 id="1-直插与贴片"><a href="#1-直插与贴片" class="headerlink" title="1. 直插与贴片"></a>1. 直插与贴片</h3><p>之所以先写这个，是因为你会发现一个神奇的事情，几乎所有的常见元器件都有直插类型和贴片类型。</p><h4 id="1、直插式元器件封装"><a href="#1、直插式元器件封装" class="headerlink" title="1、直插式元器件封装"></a>1、直插式元器件封装</h4><p>直插式元器件封装的焊盘一般贯穿整个电路板，从顶层穿下，在底层进行元器件的引脚焊接，如图所示。</p><p><img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/1.jpg?raw=true" alt="1"></p><h4 id="2、贴片式元器件封装"><a href="#2、贴片式元器件封装" class="headerlink" title="2、贴片式元器件封装"></a>2、贴片式元器件封装</h4><p>贴片式的元器件，指的是其焊盘只附着在电路板的顶层或底层，元器件的焊接是在装配元器件的工作层面上进行的。</p><p><img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/2.jpg?raw=true" alt="img"></p><p>对于大多数的电子元件来说，常见的分立元件封装主要包括二极管类、电容类、电阻类和晶体管类等；常见的集成电路类主要包括单列直插式和双列直插式等。</p><p><img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/3.jpg?raw=true" alt="img"></p><p>根据经验总结二者本质上并无电器属性上的差别，只是焊接方式不同，能够使用直插的也可以使用同类可替代的贴片。我就曾经在电源电路中用错封装，将电感从贴片型用成了直插型，而焊接出来之后发现其实稳压也是正常的。</p><h3 id="2-电阻"><a href="#2-电阻" class="headerlink" title="2. 电阻"></a>2. 电阻</h3><h4 id="贴片电阻"><a href="#贴片电阻" class="headerlink" title="贴片电阻"></a>贴片电阻</h4><p>电阻标准由 IEC（国际电工委员会）制定，标准文件为 IEC60063 和 EN60115-2。 </p><p>电子元器件厂商为了便于元件规格的管理和选用，同时也为了使电阻的规格不至太多，采用了统一的标准组成的元件的数值。</p><p>电阻的标称阻值分为 E6、E12、E24、E48、E96、E192 六大系列，分别使用于允许偏差为±20、± 10%、±5%、±2%、±1%、±0.5%的电阻器。其中以 E24 和 E96 两个系列为最常用。</p><p> “E”表示“指数间距”（Exponential Spacing），它表明了电阻阻值是由公式计算出来的，R&#x3D;$(\sqrt[n]{10})^m$。</p><p>字母 n 指的是 E24，E96 等标准中的数值 24 和 96，m 的取值范围为 0~n-1；这样，E24 有 24 个基 准值，E96 有 96 个基准值，这些基准值再乘以 10 的 x次方，就可以得到各种各样的电阻值了。</p><p>2.1.1.2、电阻丝印</p><p>封装 0603 以上的电阻（包含 0603）在表面都印有丝印。 </p><p>丝印展示出了 2 层意义：<strong>阻值大小和精度。</strong></p><p> 常用电阻丝印一般有这几种情况： </p><p>1） 带有三位或者四位数字的丝印 </p><p>2） 带有字母“R”的丝印 </p><p>3）带有数字和 R 之外字母的丝印</p><p>1、带有三位或者四位数字的丝印</p><p>三位数字表示 5%精度的，四位数字表示 1%精度的，前面几位表示数值，最后一位表示 10 的 x 次方。</p><p>例 1：丝印为“103”，则：<em><strong>R</strong></em> <strong>&#x3D; 10 ∗ 10^3^ &#x3D; 10𝐾</strong>，5%精度</p><p>例 2：丝印为“1003”，则：<strong><em>R</em> &#x3D; 100 ∗ 10^3^ &#x3D; 100𝐾</strong>，1%精度 </p><p>2、带有字母“R”的丝印</p><p>带字母”R”的电阻一般阻值较小，精度多为 1%，不过也不绝对，可以把 R 看作是小数点，前边的数字 为有效值。</p><p>例：丝印为“22R0”，将 R 看作小数点，前面的 22 表示有效值，读数为 22.0Ω，即精度为 22Ω的 1%精度电阻。</p><p>3、带有数字和 R 之外字母的丝印</p><p>这种电阻丝印在 0603 封装中比较常见，精度为 1%，与之对应的标准为 E-96。 E-96 规定：用两位数字加一个字母作为丝印，实际阻值可以通过查表来获取，两位数字表明了电阻 数值，字母表明了 10 的 x 次方，也需要查表。</p><p>自恢复保险丝：</p><p>​Ihold（保持电流）：25°C环境条件下，在这个电流之下保险丝会维持一个较低的电阻。</p><p>​Itrip（跳闸电流）：25°C环境条件下，自恢复保险丝电阻变大的最小电流。</p><p>​Vmax（最大电压）：25°C环境条件下，能承受的最大电压。</p><p>常用电路：电流过流保护电路、电源防反接电路、IO防护电路。</p><h3 id="3-电容"><a href="#3-电容" class="headerlink" title="3. 电容"></a>3. 电容</h3><h3 id="4-电感"><a href="#4-电感" class="headerlink" title="4. 电感"></a>4. 电感</h3><p>温升电流是指电感在工作时所能承受的最大电流，超过该电流会导致电感发热，可能影响电感的性能和寿命。温升电流通常由电感的材料、结构和散热条件等因素决定。</p><p> 额定电流是指电感在设计和制造过程中确定的能够长时间运行的安全电流。电感的额定电流是根据电感的材料、结构、散热能力等因素进行计算和测试得出的。在额定电流范围内，电感能够正常工作而不过热或损坏。</p><p> 在选择电感时，需要根据应用的需求和设计要求来确定所需的温升电流和额定电流。通常情况下，温升电流应小于或等于额定电流，以确保电感能够在长时间工作时保持稳定和可靠的性能。</p><h3 id="5-二极管"><a href="#5-二极管" class="headerlink" title="5.二极管"></a>5.二极管</h3><h3 id="6-连接器"><a href="#6-连接器" class="headerlink" title="6. 连接器"></a>6. 连接器</h3><p>连接器是一种机电器件，将不同的电子电器模块或系统进行电气连接。</p><p><img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/4.png?raw=true" alt="img"></p><p>准备智能车时，能接触到的连接件不多，但是熟练使用不同的连接件，能够增加许多方便。</p><h4 id="6-1-杜邦线"><a href="#6-1-杜邦线" class="headerlink" title="6.1 杜邦线"></a>6.1 杜邦线</h4><h4 id="6-2-红白线"><a href="#6-2-红白线" class="headerlink" title="6.2 红白线"></a>6.2 红白线</h4><h4 id="6-3-插母以及排针"><a href="#6-3-插母以及排针" class="headerlink" title="6.3 插母以及排针"></a>6.3 插母以及排针</h4><h4 id="6-4-FPC软排线以及FPC底座"><a href="#6-4-FPC软排线以及FPC底座" class="headerlink" title="6.4 FPC软排线以及FPC底座"></a>6.4 FPC软排线以及FPC底座</h4><h4 id="6-5-xxxx"><a href="#6-5-xxxx" class="headerlink" title="6.5 xxxx"></a>6.5 xxxx</h4><h3 id="7-MOS管"><a href="#7-MOS管" class="headerlink" title="7. MOS管"></a>7. MOS管</h3><p>这一部分，建议先跳转至H桥电路的介绍中，了解电机驱动的H桥电路，再前来观看。</p><p>通过数据手册datasheet详细讲解NMOS管，应该重点关注哪些参数，以及他们的作用，很重要，电子工程师必须要掌握。这样就可以选择逐飞或龙邱的方案的合适的平替产品去减少预算。关于MOS管，东芝公司、英飞凌公司无疑是其中的佼佼者，但是在立创商城里面看的国产的MOS管有些性能也很不错，价格上也更占优势。因为学硬件很烧钱，所以强烈建议学查看元器件参数，了解怎么去查找平替的产品。</p><p>需要关注的参数由Rgs，Id，Vgs。</p><p>一般来说，Rgs越大，寄生电容就越小，但是MOS管造成的损耗也就越大；而Rgs越小，寄生电容也就越大，相对的，MOS管造成的损耗也就较小。</p><p>在此提出一些个人见解，智能车店铺中提供的驱动上MOS管型号为东芝的TPH1R403NL，该MOS管具有高达150A的连续漏电流(Id)，而板子上的接线端子能够通过的最大电流不超过20A，所以根据木桶效应，是端子的最大承受电流限制了该驱动能够输出给电机驱动的最大电流值（且普通情况下几乎不可能达到接线端子所能承受的最大电流），所以<strong>应该可以选择更换价格更加低廉一些、封装更小一些、Id更小一些的MOS管用于电机驱动</strong>，即便是选择Id为90A的MOS管，相对于接线端子能够承受的最大电流仍然有接近四倍的冗余。</p><p>同时，MOS管可以用于电机驱动，但这并不意味着MOS管就只有这一个功能，MOS可用到的功能有许多，这里列举一个双电源选择功能。</p><h3 id="8-电池"><a href="#8-电池" class="headerlink" title="8. 电池"></a>8. 电池</h3><p>常用的有2S锂电池，3S锂电池以及6S锂电池。</p><p>在”xS电池”中，”S”表示串联（Series）。</p><p>“S”是一种用来描述电池连接方式的符号。当电池以串联方式连接时，它们的正极与负极依次相连，从而形成一个电池组。每个电池的电压会叠加，因此串联电池组的总电压等于单个电池电压的总和。例如在”2S电池”中，数字”2”表示有两个电池被串联连接在一起。</p><p>串联连接电池可以增加电压，而并联连接电池可以增加电流。这种串并联的组合方式常用于构建具有特定电压和容量要求的电池组，以满足特定的应用需求。</p><p>要注意，正常的一块锂电池电压为3.7-4.2V，所以2S锂电池正常工作电压为7.4-8.4V，超过8.4或者低于7.4都有潜在危险，请在正常电压范围内使用。</p><p>电池低于工作电压为过放，电源不可长时间处于过放状态，会损耗电池寿命，可能会导致电芯充不进去电。<strong>所以强烈建议每组配备一个BB响或者电源检测电路，逐飞科技的原理图中增加了电压测量模块，建议在程序中写上如果电压低于额定值蜂鸣器响起警报。</strong></p><p><img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/5.jpg?raw=true" alt="img"></p><h3 id="9-数码管"><a href="#9-数码管" class="headerlink" title="9. 数码管"></a>9. 数码管</h3><p>熟练使用数码管，可以显示许多数值。</p><p>数码管驱动分为两种方式，单片机直接扫描以及专用驱动芯片，单片机直接扫描硬件设计简单，但是会耗费大量CPU时间，并且占用的CPU引脚较多，并不推荐。</p><h3 id="10-LED"><a href="#10-LED" class="headerlink" title="10. LED"></a>10. LED</h3><p>5730灯珠：色温越低越接近白色，色温高发出暖光。白光在视觉上最亮。</p><h2 id="二、常用电路"><a href="#二、常用电路" class="headerlink" title="二、常用电路"></a>二、常用电路</h2><h3 id="1-电源电路"><a href="#1-电源电路" class="headerlink" title="1 电源电路"></a>1 电源电路</h3><p>首先要了解几个名词</p><table><thead><tr><th></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td><strong>名词</strong></td><td align="center"><strong>AC</strong></td><td align="center"><strong>DC</strong></td></tr><tr><td><strong>解释</strong></td><td align="center"><strong>交流电</strong></td><td align="center"><strong>直流电</strong></td></tr><tr><td><strong>名词</strong></td><td align="center"><strong>AC-AC</strong></td><td align="center"><strong>AC-DC</strong></td></tr><tr><td><strong>解释</strong></td><td align="center"><strong>从交流电转变为交流电<br>（电压变化）</strong></td><td align="center"><strong>将交流电转变为直流电</strong></td></tr><tr><td><strong>名词</strong></td><td align="center"><strong>DC-AC</strong></td><td align="center"><strong>DC-DC</strong></td></tr><tr><td><strong>解释</strong></td><td align="center"><strong>将直流电转变为交流电</strong></td><td align="center"><strong>将直流电转变为直流电<br>（电压变化）</strong></td></tr></tbody></table><p>常见的电源电路从电的类型上分为AC-AC、AC-DC、DC-AC、DC-DC。因为智能车阶段所用到的都是直流电池供电，所以接触到的电源电路为DC-DC电路。</p><p>其中，DC-DC电路又有升压型与降压型之分，因为只接触到了降压型的DC-DC电路，所以这里只介绍降压型的电路。我留下了足够的空白，后来者感兴趣可以补充升压型电路。</p><p>DC-DC的降压型电路又可以细分为BUCK电路（开关电路）以及LDO电路（低功耗线性稳压电路），二者原理如下：</p><p><strong><u>BUCK电路</u></strong></p><p>关于Buck电路的稳压电压计算，可以查看datesheet来进行。</p><p>以下是二者的对比。</p><table><thead><tr><th align="center"></th><th align="center">BUCK</th><th align="center">LDO</th></tr></thead><tbody><tr><td align="center">效率</td><td align="center">效率较高</td><td align="center">效率较低，一般看根据降压大小</td></tr><tr><td align="center">输入输出电压差</td><td align="center">能够处理较大的输入输出电压差</td><td align="center">在输入输出电压差较小时效果较好，<br>当输入电压接近输出电压时效率会显著降低。</td></tr><tr><td align="center">纹波</td><td align="center">输出电压可能存在一定的纹波</td><td align="center">输出电压较为稳定，纹波较小</td></tr><tr><td align="center">成本和复杂度</td><td align="center">设计和实现相对较复杂，涉及到开关元件<br>和电感器的使用，还需要考虑开关频率和<br>电感器尺寸等因素</td><td align="center">设计和实现相对简单，因为它只需要<br>使用一个线性稳压器。和一些滤波电容。</td></tr><tr><td align="center">应用范围</td><td align="center">通常用于需要较高效率和较大输入输出电压差的应用</td><td align="center">适用于要求较低纹波、较小输入输出电<br>压差、但对效率要求相对较低的应用</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>由此可见，BUCK电路与LDO电路有着不同的实用场合，目前建议是使用BUCK电路将电池电压稳压至5V，而对于需要3.3V供电的元器件，则使用LDO电路来进行稳压并供电。在这里做一个建议，对于单片机的供电，建议选取额外的一路LDO电路来进行，因为其输出纹波较小，不易对产生损坏。</p><h4 id="1-1-典型电源芯片及其对应电路"><a href="#1-1-典型电源芯片及其对应电路" class="headerlink" title="1.1 典型电源芯片及其对应电路"></a>1.1 典型电源芯片及其对应电路</h4><h5 id="1-1-1-LM2596电源芯片（BUCK）"><a href="#1-1-1-LM2596电源芯片（BUCK）" class="headerlink" title="1.1.1 LM2596电源芯片（BUCK）"></a>1.1.1 LM2596电源芯片（BUCK）</h5><p>LM2596是一款常用的降压（Buck）型直流-直流（DC-DC）转换器芯片，由德州仪器（Texas Instruments）公司生产。LM2596芯片具有高效率、稳定的输出电压和较大的输入-输出电压差，广泛用于电源管理和电路设计中。</p><p>LM2596芯片可将较高的输入电压降低为所需的较低输出电压，并通过内置的开关元件、电感器和电容器实现电压转换。它可以在多种应用中使用，如电池充电器、调光电路、电子设备等。LM2596芯片提供了多种不同版本和封装，以适应不同应用的需求。</p><p>LM2596芯片具有以下特点：</p><ol><li><p>高效率：LM2596芯片<strong>采用PWM（脉宽调制）控制方式</strong>，以降低功率损耗并提高转换效率。</p></li><li><p>宽输入电压范围：LM2596芯片可以适应较大的输入电压范围，一般为<strong>4.5V至40V</strong>。</p></li><li><p>可调输出电压：LM2596芯片支持可调的输出电压，可以通过外部电阻分压来设置所需的输出电压。</p></li><li><p>内置保护功能：LM2596芯片<strong>内置了过温保护、过载保护和短路保护</strong>等功能，以确保电路的安全运行。</p></li></ol><h5 id="1-1-2-LM2940电源芯片（LDO）"><a href="#1-1-2-LM2940电源芯片（LDO）" class="headerlink" title="1.1.2 LM2940电源芯片（LDO）"></a>1.1.2 LM2940电源芯片（LDO）</h5><p>LM2940是德州仪器（Texas Instruments）生产的一款低压差线性稳压器（LDO）芯片。LM2940系列提供了多个型号和封装选项，适用于各种电源管理应用。</p><p>以下是LM2940系列的一些常用型号和封装：</p><ol><li><p>LM2940CT-5.0：这是一种TO-220封装的LM2940型号，具有三个引脚。它能够提供5V的稳定输出电压。</p></li><li><p>LM2940T-5.0：这是一种TO-220封装的LM2940型号，也能够提供5V的稳定输出电压。</p></li><li><p>LM2940S-5.0：这是一种SOT-223封装的LM2940型号，具有四个引脚。同样，它提供5V的稳定输出电压。</p></li></ol><p>除了5V输出型号外，LM2940系列还提供了其他输出电压的选项，如3.3V、12V等，以满足不同的应用需求。</p><p>LM2940芯片的特点包括：</p><ol><li>低压差：LM2940是一种低压差稳压器，可以在较大的输入-输出电压差下工作，以提供稳定的输出电压。</li><li>高效率：LM2940采用低静态电流设计，以实现高效率的电源转换。</li><li>过热保护：芯片内部具有过热保护电路，可以保护芯片免受过热损坏。</li><li>短路保护：LM2940具有短路保护功能，可以防止输出短路时对芯片造成损坏.</li></ol><h5 id="1-1-3-SP1N28STER电源芯片（Buck）"><a href="#1-1-3-SP1N28STER电源芯片（Buck）" class="headerlink" title="1.1.3 SP1N28STER电源芯片（Buck）"></a>1.1.3 SP1N28STER电源芯片（Buck）</h5><h4 id="1-2-关于纹波"><a href="#1-2-关于纹波" class="headerlink" title="1.2 关于纹波"></a>1.2 关于纹波</h4><h5 id="第一部分：输出电压纹波"><a href="#第一部分：输出电压纹波" class="headerlink" title="第一部分：输出电压纹波"></a>第一部分：输出电压纹波</h5><p>以Buck电路为例，由于寄生参数的影响，实际Buck电路的输出电压并非是稳定干净的直流电压，而是在直流电压上叠加了输出电压纹波和噪声，如图1所示。</p><p><img src="https://e2echina.ti.com/resized-image/__size/2460x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-01-16/3858.1.png" alt=" "></p><center>图1. Buck 输出电压纹波和噪声</center><p>实际输出电压纹波由电感电流与输出阻抗决定，由三部分组成，如图2 所示。</p><ol><li>电感电流纹波通过输出电容的寄生电阻ESR形成的压降</li><li>输出电容的充放电</li><li>寄生电感引起的电压突变</li></ol><p><img src="https://e2echina.ti.com/resized-image/__size/2460x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-01-16/0118.2.png" alt=" "></p><center>图2. 输出电压纹波的组成</center><p>不同类型的输出电容，寄生参数的大小不同，三部分纹波所占的比例也有所不同。因此，使用不同类型的输出电容会得到不同波形的电压纹波。如图3所示，电解电容的ESR较大，纹波由ESR主导，波形与电感电流纹波形状类似。陶瓷电容的ESR和ESL都很小，主要由电容的充放电主导，纹波类似电容的充放电曲线。OSCON电容三者的影响都体现在纹波中。</p><p><img src="https://e2echina.ti.com/resized-image/__size/2460x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-01-16/7026.3.png" alt=" "></p><center>图3. 不同类型输出电容的电压纹波</center><h5 id="第二部分：输出电压纹波的测量"><a href="#第二部分：输出电压纹波的测量" class="headerlink" title="第二部分：输出电压纹波的测量"></a>第二部分：输出电压纹波的测量</h5><p>在测量输出电压纹波时，要注意如下几点，正确方式如图4所示。</p><ol><li>保证接地环路尽可能小，建议使用接地环</li><li>探头应靠近电容两侧</li><li>避免同时使用示波器其他通道测试其他点位的波形</li><li>如果只关注开关频率分量纹波，建议打开示波器带宽限制</li></ol><p>如图5所示，左侧波形同时测量开关节点和输出电压纹波，带宽限制关闭。可以看到，输出电压纹波中的噪声较大，影响纹波的测量。</p><p><img src="https://e2echina.ti.com/resized-image/__size/2460x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-01-16/5355.4.png" alt=" "></p><center>图4. 输出电压纹波测试方式</center><p><img src="https://e2echina.ti.com/resized-image/__size/2460x0/__key/communityserver-blogs-components-weblogfiles/00-00-00-01-16/3162.5.png" alt=" "></p><center>图5. 输出电压纹波测试对比</center><p>转载不完整，详细请点开下方链接。</p><p><a href="https://e2echina.ti.com/blogs_/b/power_house/posts/53234">理解输出电压纹波和噪声一：输出电压纹波来源和抑制 - 电源管理 - 技术文章 - E2E™ 设计支持 (ti.com)</a></p><p><a href="https://e2echina.ti.com/blogs_/b/power_house/posts/53235">理解输出电压纹波和噪声二：高频噪声分量的来源和抑制 - 电源管理 - 技术文章 - E2E™ 设计支持 (ti.com)</a></p><h3 id="2-H桥电机驱动电路"><a href="#2-H桥电机驱动电路" class="headerlink" title="2. H桥电机驱动电路"></a>2. H桥电机驱动电路</h3><p>虽然直流无刷电机加压后就可以转动，但是却存在着诸多问题，例如：不能够调节转速，可能会烧毁电机等等。目前控制直流有刷电机多采用全H桥电路驱动电机电路。使用H桥电路来控制直流有刷电机可以实现双向控制、调速控制、制动功能、PWM速度控制以及电流保护等优势，使得电机的控制更加灵活、可靠和精确。</p><p>H桥是一个比较简单的电路，通常它会包含四个独立控制的开关元器件（例如MOSFET）,它们通常用于驱动电流较大的负载，比如电机。H桥式电机驱动电路包括4个三极管和一个电机。要使电机运转，必须导通对角线上的一对三极管。根据不同三极管对的导通情况，电流可能会从左至右或从右至左流过电机，从而控制电机的转向。H桥是一种电子电路，可使其连接的负载或输出端两端电压反相&#x2F;电流反向。这类电路可用于机器人及其它实作场合中直流电动机的顺反向控制及转速控制、步进电机控制（双极型步进电机还必须要包含两个H桥的电机控制器），电能变换中的大部分直流-交流变换器（如逆变器及变频器）、部分直流-直流变换器（推挽式变换器）等，以及其它的功率电子装置。</p><p>H桥电路，既可以分立元器件形式搭建，也可以整合到集成电路上。“H桥”的名称起源于其电路，两个并联支路和一个负载接入&#x2F;电路输出支路，看上去构成了形如“H”字母的电路结构。</p><p> <img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/6.png?raw=true" alt="image-20230708193050763"></p><p>​                               </p><p>从上图可以看出，电路是由四个NMOS管，一个motor，以及VCC，GND所构成的。可以控制栅极的电平高低，来控制NMOS管的开通与关闭，所以可以通过控制四个栅极的状态来控制MOS管的开通与关断，从而达到控制电机正反转的效果。</p><p>H桥的工作模式：</p><p>正转模式：当Q1、Q4的栅极为高电平，Q2、Q3为低电平时，Q1、Q4导通，电机正向旋转。</p><p> <img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/7.png?raw=true" alt="image-20230708193439709"></p><p>反转模式：当Q1、Q4的栅极为低电平，Q2、Q3为高电平时，Q2、Q3导通，电机反向旋转。</p><p> <img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/8.png?raw=true" alt="image-20230708193445247"></p><p>通过总结讨论，选用Ｈ桥实现驱动电路，H桥电路结构稳定，性能优良，可实现性高。</p><p>在实际应用中，这样的电机驱动电路是不行的，电机是感性负载，在电路中电流不会发生突变。如果在断开电机两端所加的电压时，电机产生的反向电动势很有可能损坏FET。因此想让电机停下，除了断开供电，还要形成一个续流的回路，释放掉电机上的能量。可以在MOS管的源极和漏极上并联一个寄生二极管，寄生二极管的方向和栅极方向相同，如下图：</p><p> <img src="https://github.com/Trace12364/Trace12364.github.io/blob/main/images/ima/9.png?raw=true" alt="image-20230708193505231"></p><h3 id="3-电流环电路"><a href="#3-电流环电路" class="headerlink" title="3. 电流环电路"></a>3. 电流环电路</h3><p>在电机驱动过程中，调节的Pid会受到电源电压的影响，可能你在电源为8.3V时的Pid在7.8V时就无法使用，解决此类问题，可以固定电源电压，一直在某个电压下调节Pid，或者，加一个电流环电路，保证驱动电机的电流在不同电压下相同，同时在代码中增加电流环的Pid。</p><p>在无刷驱动中有用到电流环相关的电路，也可以增加到有刷驱动中，具体设计请自行查找资料。</p><p>要研究此电路，需要与软件队友钻研或者硬件同学学习软件内容。</p><p>因为并没有相关的资料，且智能车在有刷电机中增加电流环电路的参考也极少，所以在有刷驱动上增加电流环电路能够得到多少收益还有待测试。</p><h3 id="4-关于无线充电"><a href="#4-关于无线充电" class="headerlink" title="4. 关于无线充电"></a>4. 关于无线充电</h3><p>在智能车比赛中，无线充电是一个常驻项目。18届参赛队伍发现他们必须充电到6V才能够驱动电机，而其他学校只需要充电到2V即可。关于此，17届节能充电组学长已经遇到并且解决。</p><p>个人认为可以使用低降压&#x2F;升压转换器来进行对电压的恒定处理，降压&#x2F;升压转换器作用为，V<del>out</del>输出电压固定，当V<del>in</del>&lt;V<del>out</del>，时，进行升压处理；当V<del>in</del>&gt;V<del>out</del>时，则会进行降压处理。</p><p>智能车店铺提供的常见降压&#x2F;升压转换器型号为TPS63070，具有宽输入电压（2V-16V），输出电压范围（2.5V-9V），升降压模式下输出电流均为2A。要注意的是，该芯片采用的是2.5mm x 3mm QFN封装，因此较为考验焊接技术。</p><h3 id="5-按键拓展"><a href="#5-按键拓展" class="headerlink" title="5. 按键拓展"></a>5. 按键拓展</h3><p>人机交互需要众多按键，而通常一个按键需要一个IO口，</p><h3 id="6-数码管显示电路"><a href="#6-数码管显示电路" class="headerlink" title="6. 数码管显示电路"></a>6. 数码管显示电路</h3><p>TM1640芯片。</p><h2 id="三、PCB绘制注意事项"><a href="#三、PCB绘制注意事项" class="headerlink" title="三、PCB绘制注意事项"></a>三、PCB绘制注意事项</h2><center>！！！</center><p><strong>最重要的时绘制PCB前先看芯片手册，芯片手册会把注意事项都列出，一定一定一定要先看一遍，能少走弯路，Trace学长血一般的教训！！！</strong></p><center>！！！</center><h3 id="1-数字地与模拟地"><a href="#1-数字地与模拟地" class="headerlink" title="1 .数字地与模拟地"></a>1 .数字地与模拟地</h3><p><strong>（有所了解，知道需要两个地进行隔离就行，你们死磕可能也理解不了）</strong></p><p>转载至CSDN<a href="https://blog.csdn.net/kevinhg/article/details/12080751">(3条消息) 模拟地与数字地详解_数字地和模拟地的区别_kevinhg的博客-CSDN博客</a></p><p>二者本质是一直的，就是数字地和模拟地都是地。要明白为什么要分开，先听一个故事；我们公司的商务楼，2楼是搞模拟的，3楼是搞数字的，整幢楼只有一部电梯，平时人少的时候还好办，上2楼上3楼互不影响，但每天上下班的时候就不得了了，人多得很，搞数字的要上3楼，总是被2楼搞模拟的人影响，2楼模拟的人要下楼，总是要等电梯上了3楼再下来，互相影响很是麻烦，商务楼的物业为解决这个问题，提出了2个方案：第1个（笑死人了）电梯扩大，可以装更多的人，电梯大了是好，但公司会招人，人又多了，再换电梯，再招人…永远死循环，有一个办法到挺好，大家索性不要电梯，直接往下跳，不管2楼的3楼的，肯定解决问题，但肯定会出问题（第1个被枪毙掉了）。第2个办法装2部电梯，一部专门上2楼，另一部专门上3楼，Wonderful！太机智了，这样2层楼面的工作人员就互不影响了。明白了否？</p><p> 数字地、模拟地互相会影响不是因为一个叫数字，一个叫模拟，而是他们用了同一部电梯：地，而这部电梯所用的井道就是我们在PCB上布得地线。模拟回路的电流走这条线，数字回路的电流也走这条线，本来无可厚非，线布着就是用来导通电流的，可问题出在这根线上有电阻！而且最根本的问题是走这条线的电流要去2个不同的回路。假设一下：有2股电流，数流，模流同时从地出发。有2个器件：数字件和模拟件。若2个回路不分开，数流模流走到数字件的接地端前的时候，损耗的电压为V&#x3D;（数流+模流）X走线电阻，相当于数字器件的接地端相对于地端升高了V，数字器件不满意了，我承认会升高少许电压，数流的那部分我认了，但模流的为什么要加在我头上？同理模拟器件也会同样抱怨！</p><p>两个解决方案：第1个：你布的PCB线没有阻抗，自然不会引起干扰，就像2、3楼直接往下跳，那是井道最宽的时候，也就是可以装一个无限大的电梯，自然谁都不影响谁，但谁都知道，This is mission impossible！第2个：2条回路分开走，数流，模流分开，既数地、模地分开。</p><p>同理，有时虽在模拟回路中，但也要分大、小电流回路，就是避免相互干扰。所谓的干扰就是：2个不同回路中的电流在PCB走线上引起的电压，这2部分电压互相叠加而产生的。    </p><p>下面再具体介绍，简单来说，数字地是数字电路部分的公共基准端，即数字电压信号的基准端；模拟地是模拟电路部分的公共基准端，模拟信号的电压基准端（零电位点）。</p><h5 id="一、分为数字地和模拟地的原因"><a href="#一、分为数字地和模拟地的原因" class="headerlink" title="一、分为数字地和模拟地的原因"></a>一、分为数字地和模拟地的原因</h5><p>由于数字信号一般为矩形波，带有大量的谐波。如果电路板中的数字地与模拟地没有从接入点分开，数字信号中的谐波很容易会干扰到模拟信号的波形。当模拟信号为高频或强电信号时，也会影响到数字电路的正常工作。模拟电路涉及弱小信号，但是数字电路门限电平较高，对电源的要求就比模拟电路低些。既有数字电路又有模拟电路的系统中，数字电路产生的噪声会影响模拟电路，使模拟电路的小信号指标变差，克服的办法是分开模拟地和数字地。</p><p>存在问题的根本原因是，无法保证电路板上铜箔的电阻为零，在接入点将数字地和模拟地分开，就是为了将数字地和模拟地的共地电阻降到最小。</p><h5 id="二、数字地和模拟地处理的基本原则如下"><a href="#二、数字地和模拟地处理的基本原则如下" class="headerlink" title="二、数字地和模拟地处理的基本原则如下"></a>二、数字地和模拟地处理的基本原则如下</h5><p>如果把模拟地和数字地大面积直接相连，会导致互相干扰。不短接又不妥。对于低频模拟电路，除了加粗和缩短地线之外，电路各部分采用一点接地是抑制地线干扰的最佳选择，主要可以防止由于地线公共阻抗而导致的部件之间的互相干扰。</p><p>而对于高频电路和数字电路，由于这时地线的电感效应影响会更大，一点接地会导致实际地线加长而带来不利影响，这时应采取分开接地和一点接地相结合的方式。另外对于高频电路还要考虑如何抑制高频辐射噪声，方法是：尽量加粗地线，以降低噪声对地阻抗；满接地，即除传输信号的印制线以外，其他部分全作为地线。不要有无用的大面积铜箔。</p><p>地线应构成环路，以防止产生高频辐射噪声，但环路所包围面积不可过大，以免仪器处于强磁场中时，产生感应电流。但如果只是低频电路，则应避免地线环路。数字电源和模拟电源最好隔离，地线分开布置，如果有A&#x2F;D，则只在此处单点共地。低频中没有多大影响，但建议模拟和数字一点接地。高频时，可通过磁珠把模拟和数字地一点共地。</p><h5 id="三、四种解决方法"><a href="#三、四种解决方法" class="headerlink" title="三、四种解决方法"></a>三、四种解决方法</h5><p>模拟地和数字地间的串接可以采用四种方式：1、用磁珠连接；2、用电容连接（利用电容隔直通交的原理）；3、用电感连接（一般用几uH到数十uH）；4、用0欧姆电阻连接。下面重点介绍一下磁珠和0欧姆电阻：</p><p>一般情况下，用0欧电阻是最佳选择，1、可保证直流电位相等；2、单点接地，限制噪声；3、对所有频率的噪声都有衰减作用（0欧也有阻抗，而且电流路径狭窄，可以限制噪声电流通过）；4、电容（利用电容隔直通交的原理）。<br>        磁珠采用在高频段具有良好阻抗特性的铁氧体材料烧结面成，专用于抑制信号线、电源线上的高频噪声和尖峰干扰，还具有吸收静电脉冲的能力。磁珠有很高的电阻率和磁导率，等效于电阻和电感串联，但电阻值和电感值都随频率变化。它比普通的电感有更好的高频滤波特性，在高频时呈现阻性，所以能在相当宽的频率范围内保持较高的阻抗，从而提高调频滤波效果。磁珠对高频信号才有较大阻碍作用，一般规格有100欧&#x2F;100mMHZ，它在低频时电阻比电感小得多。铁氧体磁珠（Ferrite Bead）是目前应用发展很快的一种抗干扰组件，廉价、易用，滤除高频噪声效果显着。</p><p>铁氧体磁珠不仅可用于电源电路中滤除高频噪声（可用于直流和交流输出），还可广泛应用于其它电路，其体积可以做得很小。特别是在数字电路中，由于脉冲信号含有频率很高的高次谐波，也是电路高频辐射的主要根源，所以可在这种场合发挥磁珠的作用。在电路中只要导线穿过它即可。当导线中电流穿过时，铁氧体对低频电流几乎没有什么阻抗，而对较高频率的电流会产生较大衰减作用。</p><h5 id="四-电感与磁珠的区别"><a href="#四-电感与磁珠的区别" class="headerlink" title="四.电感与磁珠的区别"></a>四.电感与磁珠的区别</h5><p>有一匝以上的线圈习惯称为电感线圈，少于一匝（导线直通磁环）的线圈习惯称之为磁珠。电感是储能元件，而磁珠是能量转换（消耗）器件，电感多用于电源滤波回路，磁珠多用于信号回路，用于EMC对策；磁珠主要用于抑制电磁辐射干扰，而电感用于这方面则侧重于抑制传导性干扰。两者都可用于处理EMC、EMI问题；电感一般用于电路的匹配和信号质量的控制上，在模拟地和数字地结合的地方用磁珠。<br>   作为电源滤波，可以使用电感。磁珠的电路符号就是电感但是型号上可以看出使用的是磁珠在电路功能上，磁珠和电感是原理相同的，只是频率特性不同罢了;磁珠由氧磁体组成，电感由磁心和线圈组成，磁珠把交流信号转化为热能，电感把交流存储起来，缓慢的释放出去。<br>    电感是储能元件，而磁珠是能量转换（消耗）器件；电感多用于电源滤波回路，磁珠多用于信号回路，用于EMC对策；磁珠主要用于抑制电磁辐射干扰，而电感用于这方面则侧重于抑制传导性干扰。两者都可用于处理EMC、EMI问题。磁珠是用来吸收超高频信号，象一些RF电路，PLL，振荡电路，含超高频存储器电路（DDR SDRAM，RAMBUS等）都需要在电源输入部分加磁珠，而电感是一种蓄能元件，用在LC振荡电路，中低频的滤波电路等，其应用频率范围很少超过50MHZ。</p><h5 id="五、几种方法综述"><a href="#五、几种方法综述" class="headerlink" title="五、几种方法综述"></a>五、几种方法综述</h5><p>电容隔直通交，造成浮地。电容不通直流，会导致压差和静电积累，摸机壳会麻手。如果把电容和磁珠并联，就是画蛇添足，因为磁珠通直，电容将失效。串联的话就显得不伦不类。</p><p>电感体积大，杂散参数多，特性不稳定，离散分布参数不好控制，体积大。电感也是陷波，LC谐振(分布电容)，对噪点有特效。</p><p>磁珠的等效电路相当于带阻陷波器，只对某个频点的噪声有抑制作用，如果不能预知噪点，如何选择型号，况且，噪点频率也不一定固定，故磁珠不是一个好的选择。</p><p>0欧电阻相当于很窄的电流通路，能够有效地限制环路电流，使噪声得到抑制。电阻在所有频带上都有衰减作用(0欧电阻也有阻抗)，这点比磁珠强。</p><p>总之，关键是模拟地和数字地要一点接地。建议，不同种类地之间用0欧电阻相连；电源引入高频器件时用磁珠；高频信号线耦合用小电容；电感用在大功率低频上。 </p><h3 id="2-高频滤波电路"><a href="#2-高频滤波电路" class="headerlink" title="2.高频滤波电路"></a>2.高频滤波电路</h3><p>在直流电源的输入端，可以通过增加电阻电容的方式构成RC串联电路来进行高频滤波。</p><h3 id="3-无刷电调"><a href="#3-无刷电调" class="headerlink" title="3.无刷电调"></a>3.无刷电调</h3><p>在18届负压电磁组别中，允许使用无刷电机来给小车加负压以增加转弯时的向心力，这时需要绘制无刷电调以启动无刷电机。</p><p>18届负压电磁用的是无感无刷电调，并未使用霍尔检测换相，所以需要在程序中增加过零检测，且在电路中增加过零检测相应的电路。</p><p>这里需要注意一点，<strong>无刷电调的换相检测中的电阻要使用高精度电阻，推荐精度为0.1%，自举电路中二极管应靠近自举电容，且过零检测部分靠近预驱芯片。距离过远会导致产生的方波不完整，从而导致电调无法使用</strong></p><p>（有待补充）</p><h2 id="四、常用传感器"><a href="#四、常用传感器" class="headerlink" title="四、常用传感器"></a>四、常用传感器</h2><p>因为我们是从智能车竞赛开始的接触各类传感器，所有文章中大多介绍的是在智能车阶段所接触到的传感器。</p><h3 id="1-电磁传感器"><a href="#1-电磁传感器" class="headerlink" title="1.电磁传感器"></a>1.电磁传感器</h3><p>电磁组，智能车竞赛中非常经典的组别，同时也是比较卷的组别，因为其循迹实现简单，组别的传承也多，资料也多。</p><p>电磁循迹，本质上是根据LC并联选频网络的原理，赛道上会有20KHz的正弦信号，在这个变化的磁场上，电感能够感应出电动势，而后将感应出的电动势数值通过运算放大器放大后输出到单片机中，通过单片机的ADC采样，接受采取到的电磁值。</p><p>所以，电磁循迹只需要两个电感在赛道中心两侧均匀分布就可以。而要处理一些元素，则需要增加电感的数量。在18届负压电磁组别，共有S弯、坡道、圆环、十字以及断路这些元素，所以我们使用了5个电感进行循迹。具体排布如下：</p><p><strong>—       &#x2F;       —      \      —</strong></p><p>左一  左二 中间 右二 右一</p><p>其中，左一以及右一两个电感用于循迹，中间三个电感用于识别元素。也可以使用中间两个电感以及边缘处两个电感加权循迹，但是经过检验发现这样做在十字元素中会误判，直接左转，所以需要增加一个识别十字的代码。</p><p>其实，个人认为，可以使用7个电感进行循迹，推荐排布如下：</p><p><strong>—    |    &#x2F;      —     \    |    —</strong></p><p>其中要注意，如果是使用电路板来放置电感，尽量将八字电感以及竖直的电感（如果增加了的话）与横电感不在一个直线上，可以八字电感略微靠下，竖直电感在略微靠上，同时中间挖空，方便固定。</p><p>具体可以参考本人在18届比赛中制作的电感检测板，如果想一直白嫖也可以使用两到三块PCB板来拼接构成。</p><p>因为逐飞给出的原理图上只有四个电磁接口，所以需要拓展电磁接口，拓展的方法很简单，只需要根据数据手册找到芯片上多余的ADC接口即可。</p><h3 id="2-摄像头"><a href="#2-摄像头" class="headerlink" title="2.摄像头"></a>2.摄像头</h3><p>有待补充。</p><h3 id="3-GPS"><a href="#3-GPS" class="headerlink" title="3.GPS"></a>3.GPS</h3><p>越野组使用，有待补充。</p><h3 id="4-陀螺仪"><a href="#4-陀螺仪" class="headerlink" title="4.陀螺仪"></a>4.陀螺仪</h3><p>测量自身姿态的传感器，有3\6\9\10轴之分。</p><p>三轴加速器是检测横向加速的，三轴陀螺仪是检测角度旋转和平衡的，合在一起称为六轴传感器。</p><p>所谓的六轴陀螺仪叫六轴姿态感应器比较合适 是三轴陀螺仪和加速计的合称 如果有三轴陀螺仪也有加速计那就具有六轴姿态感应。而九轴感测组件是：三轴加速度计、三轴陀螺仪、三轴磁强计，然后欧拉角加四元数数据融合。</p><p>十轴感测组件是：三轴加速度计、三轴陀螺仪、三轴磁强计，再加3轴气压，然后欧拉角加四元数数据融合。对比九轴传感器，可以测量气压高度。</p><p>大多使用的是6轴陀螺仪。</p><h3 id="5-TOF测距模块"><a href="#5-TOF测距模块" class="headerlink" title="5.TOF测距模块"></a>5.TOF测距模块</h3><h3 id="6-编码器"><a href="#6-编码器" class="headerlink" title="6.编码器"></a>6.编码器</h3><p>编码器可以精准读取脉冲数，（相当于转速）。</p><p>我们使用的是逐飞科技的方向编码器，DIR引脚为1表示正转，为0表示反转。LSB引脚读取的是脉冲数。</p><p><img src="https://img.gsimg.top/2024/04/21/10s6n28.jpg" alt="5b4df01be93dec9797ff6a57fc23b6e"></p><p><img src="https://img.gsimg.top/2024/04/21/10sr4hv.jpg" alt="92799d87fd6de9e12ad1d0f79bfd901"></p><p><img src="https://img.gsimg.top/2024/04/21/10suxrg.jpg" alt="598954be506dc83f02b2485937ef63f"></p><h2 id="五、算法相关知识"><a href="#五、算法相关知识" class="headerlink" title="五、算法相关知识"></a>五、算法相关知识</h2><h3 id="1-PID"><a href="#1-PID" class="headerlink" title="1.PID"></a>1.PID</h3><h4 id="一-定义"><a href="#一-定义" class="headerlink" title="一.定义"></a>一.定义</h4><p>PID，就是“比例（proportional）、积分（integral）、微分（derivative）”，是一种很 常见的控制算法。常见的PID有位置式PID,增量式PID，串级PID等。</p><p><img src="https://img.gsimg.top/2024/04/21/12rt30l.png" alt="img"></p><p><img src="https://img.gsimg.top/2024/04/21/12rla8u.png" alt="img"></p><p>Kp：比例增益</p><p>Ki：积分增益</p><p>Kd：微分增益</p><p>e：误差&#x3D;目标-当前值</p><p>t：积分时间&#x2F;微分时间</p><p>上面是理想公式，实际需要离散化</p><p><img src="https://img.gsimg.top/2024/04/21/12s88wj.png" alt="pid算法中位置型和增量型有什么区别，分析两者优缺点"></p><h4 id="二-为什么使用pid算法-重要"><a href="#二-为什么使用pid算法-重要" class="headerlink" title="二.为什么使用pid算法(重要)"></a>二.为什么使用pid算法(重要)</h4><p>​以电机转速为例子来解释，很多人应该都有这个疑惑，我控制转速，直接给电机输出一个PWM不就行了吗，假设我想让电机转慢一点，设置输出比较的PWM为200，我想让电机转的快一些，就给PWM输出1000，让电机全速旋转不就可以了吗?不停的进行测试，然后用编码器读取到电机当前的转速，记录下来，我就知道了电机的一个速度对应一个固定的PWM的值。<strong>大家有没有想过一个问题，电机随着使用时间的增加，电机的性能其实会发生变化，输出相同的PWM值，速度会和最开始测得的值是不一样的。</strong>我们有一辆小车（电机控制小车的速度），如果我改变小车的负重，根据生活中的常识，相同的输出电压下，负载越重，小车的速度越慢的，那么前面记录的数据都不成立了。所以说仅仅输出一个PWM值，是不能精确控制电机转动的速度保持在相同的值。这个时候PID的算法就会体现出重要的作用。现在，我用一个编码器来读取电机速度（编码器可以精确读取电机的转动速度），编码器的作用就是把电机转动的速度（模拟量）转化为一个数字量，传入到我们的微处理器。<strong>我们使用PID算法本质上是为了让编码器的值（即速度）稳定在一个值</strong></p><h4 id="三-PID三个环节的作用"><a href="#三-PID三个环节的作用" class="headerlink" title="三.PID三个环节的作用"></a>三.PID三个环节的作用</h4><ol><li>P</li></ol><p>起主要控制作用，使反馈量向目标值靠拢。</p><p>过大响应快，但是会引起震荡。过小无震荡，但是存在静态误差。</p><ol start="2"><li>D</li></ol><p>抑制震荡</p><p>当比较接近目标时，P的控制作用就比较小了。越接近目标，P的作用越温柔。有很多内在的或者外部的因素，使控制量发生小范围的摆动。D的作用就是让物理量的速度趋于0，只要什么时候，这个量具有了速度，D就向相反的方向用力，尽力抑制住振荡的变化。在自动控制原理这门学科中会提到专业的名词。现在我们引入偏差值的概念，令Bias&#x3D;taget-position，令上一次求得的偏差值为Last_Bias。D项的计算公式为Position_KD*(Bias-Last_Bias）。</p><p>我用带入值的方法来解释D的作用：现在让当前的速度值为90，目标值为100，Bias&#x3D;10。现在是为了接近目标值，所以D项的结果是增加PWM。现在增加后的速度变成了105，Bias&#x3D;-5,Last_Bias&#x3D;10，Bias-Last_Bias&#x3D;-15，如果增加后的速度为110，Bias&#x3D;-10，Last_Bias&#x3D;10，Bias-Last_Bias&#x3D;-20，D项的计算结果是为了减小PWM，快速抑制住PWM的过量增加，超过目标值越多，那么抑制能力越厉害。</p><ol start="3"><li>I</li></ol><p>PID中的I的作用是为了消除静差，静差就是指，稳定状态下当前值和目标值的差，为了让大家更清楚理解I的概念，之前看到一个很有趣的例子，这里借鉴一下：</p><p>假如有个人把我们的加热装置带到了非常冷的地方，开始烧水了。需要烧到50℃。</p><p>在P的作用下，水温慢慢升高。直到升高到45℃时，他发现了一个不好的事情：天气太冷，水散热的速度，和P控制的加热的速度相等了。</p><p>这可怎么办？</p><p>P兄这样想：我和目标已经很近了，只需要轻轻加热就可以了。<br>D兄这样想：加热和散热相等，温度没有波动，我好像不用调整什么。<br>于是，水温永远地停留在45℃，永远到不了50℃。</p><p>作为一个人，根据常识，我们知道，应该进一步增加加热的功率。可是增加多少该如何计算呢？</p><p>设置一个积分量。只要偏差存在，就不断地对偏差进行积分（累加），并反应在调节力度上。</p><p>这样一来，即使45℃和50℃相差不太大，但是随着时间的推移，只要没达到目标温度，这个积分量就不断增加。系统就会慢慢意识到：还没有到达目标温度，该增加功率啦！</p><p>到了目标温度后，假设温度没有波动，积分值就不会再变动。这时，加热功率仍然等于散热功率。但是，温度是稳稳的50℃。</p><p>kI的值越大，积分时乘的系数就越大，积分效果越明显。但要注意积分限幅，积分限幅可以减小积分引起的超调。</p><h4 id="四-增量式PID与位置式PID"><a href="#四-增量式PID与位置式PID" class="headerlink" title="四.增量式PID与位置式PID"></a>四.增量式PID与位置式PID</h4><ol><li>位置式PID<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MwLmJhaWR1LmNvbS85NG8zZFNhZ194STRraEdrbzlXVEFuRjZoaHkvemhpZGFvL3doJTNENjAwJTJDODAwL3NpZ249NWJmZjY5MDhmMjE5ODYxODQxMTJlNzgyN2FkZDAyNGIvYjgxMmM4ZmNjM2NlYzNmZDE0ZTc0YjFjZGM4OGQ0M2Y4Njk0MjdmYS5qcGc"></li></ol><p>​<strong>位置式PID是当前系统的实际位置，与你想要达到的预期位置的偏差</strong>，进行PID控制</p><ol start="2"><li>增量式PID<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MwLmJhaWR1LmNvbS85NG8zZFNhZ194STRraEdrbzlXVEFuRjZoaHkvemhpZGFvL3doJTNENjAwJTJDODAwL3NpZ249NjAyYzFhOTdjOWZkZmMwM2U1MmRlYmJlZTQwZmFiYWMvZTRkZGU3MTE5MGVmNzZjNjBmM2YxNzQyOTcxNmZkZmFhZTUxNjdlZS5qcGc" alt="img"></li></ol><p>​<strong>控制量▲u(k)对应的是近几次位置误差的增量，而不是对应与实际位置的偏差</strong>，也就是说，增量式PID中不需要累加。控制增量Δu(k)的确定仅与<strong>最近3次的采样值</strong>有关，容易通过加权处理获得比较好的控制效果，并且在系统发生问题时，增量式不会严重影响系统的工作。</p><p>(在我们的速度控制闭环系统里面，只使用PI控制)</p><ol start="3"><li><p><strong>总结：</strong>增量型 PID，是对位置型 PID 取增量，这时控制器输出的是相邻两次采样时刻所计算的位置值<br>之差，得到的结果是增量，即在上一次的控制量的基础上需要增加（负值意味减少）控制量。</p></li><li><p>增量式与位置式区别：<br>1）增量式算法不需要做累加，控制量增量的确定仅与最近几次偏差采样值有关，计算误差对控制 量计算的影响较小。而位置式算法要用到过去偏差的累加值，容易产生较大的累加误差。 </p><p>2）增量式算法得出的是控制量的增量，例如在阀门控制中，只输出阀门开度的变化部分，误动作 影响小，必要时还可通过逻辑判断限制或禁止本次输出，不会严重影响系统的工作。 而位置式的输出直接对应对象的输出，因此对系统影响较大。</p><p>3）增量式PID控制输出的是控制量增量，并无积分作用，因此该方法适用于执行机构带积分部件的对象，如步进电机等，而位置式PID适用于执行机构不带积分部件的对象，如电舵机。</p><p>4）在进行PID控制时，位置式PID需要有积分限幅和输出限幅，而增量式PID只需输出限幅</p></li></ol><h4 id="五-串级PID与并级PID"><a href="#五-串级PID与并级PID" class="headerlink" title="五.串级PID与并级PID"></a>五.串级PID与并级PID</h4><p>单级PID，目标值和反馈值经过一次PID计算就得到输出值并直接作为控制量，如果目标物理量和输出物理量直接不止差了一阶的话，中间阶次的物理量我们是无法控制的。<em>比如：目标物理量是位置，输出物理量是加速度，则小球的速度是无法控制的。</em>而串级PID就可以改善这一点。</p><p><img src="https://img-blog.csdnimg.cn/b59feebe4e6e4de6a32fcee88a35b525.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc2t5dGhpbmtlcjYxNg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>举例：直立车</p><p><img src="https://img-blog.csdnimg.cn/926d912e159a450d89ee3b90f1c5ab99.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAV3llYW4=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>串级PID1:速度环-&gt;角度环-&gt;角速度环-&gt;PWM1</p><p>串级PID2:转向角度环-&gt;转向角速度环-&gt;PWM2</p><p>并行PID：PID1_OUT+PID2_OUT</p><h2 id="六、想写的东西"><a href="#六、想写的东西" class="headerlink" title="六、想写的东西"></a>六、想写的东西</h2><h3 id="1-关于RGB灯-常见的图像颜色空间解释-Sipeed-Wiki"><a href="#1-关于RGB灯-常见的图像颜色空间解释-Sipeed-Wiki" class="headerlink" title="1.关于RGB灯  常见的图像颜色空间解释 - Sipeed Wiki"></a>1.关于RGB灯  <a href="https://wiki.sipeed.com/news/others/color_introduction/color_introduction.html">常见的图像颜色空间解释 - Sipeed Wiki</a></h3><p>红绿蓝 三色，也是大家熟悉光学三原色</p><p>RGB 使用加色模式，也就是默认是黑色，三原色相加获得白色， 比如下图<code>蓝色+绿色=青色(cyan)</code>，得到<code>蓝色=青色-绿色</code>也就是<code>蓝色=青色+绿色</code>的互补色， 绿色的互补色就是图中的<code>M(品红色）magenta</code>（同理蓝色的互补色是Y黄色）（互补色就是两者相加为白色），所以<code>蓝色=青色+品红色</code></p><p><img src="https://wiki.sipeed.com/news/others/color_introduction/assets/color_add.png" alt="img"></p><p><img src="https://wiki.sipeed.com/news/others/color_introduction/assets/coordinate_box.png" alt="img"></p><p>上图可以看到灰度图在正方体对角线上，即三个通道（轴）的值相等时，值越大越白</p><p><img src="https://wiki.sipeed.com/news/others/color_introduction/assets/color.png" alt="img"></p><p>一般两种表示方法：</p><h4 id="1-1-RGB888-24bit"><a href="#1-1-RGB888-24bit" class="headerlink" title="1.1. RGB888(24bit)"></a>1.1. RGB888(24bit)</h4><p>RGB三个通道，每个通道分别用8bit长度表示，比如(255, 255, 255), 每个通道取值范围为[0, 255]，或者0xFFFFFF三个字节表示</p><h4 id="1-2-RGB565-16bit"><a href="#1-2-RGB565-16bit" class="headerlink" title="1.2. RGB565(16bit)"></a>1.2. RGB565(16bit)</h4><p>RGB三个通道分别用5bit 6bit 5bit表示，比如(31, 63, 31)，但一般不这样表示，使用两个字节表示，比如0xFFFF, 一般在编写程序时在内存中多使用以下两种布局方式：</p><ul><li>第一种：</li></ul><p><img src="https://wiki.sipeed.com/news/others/color_introduction/assets/bgr_color.png" alt="img"></p><ul><li>第二种：</li></ul><p><img src="https://wiki.sipeed.com/news/others/color_introduction/assets/grgb_color.png" alt="img"></p><p>这两种方式的不同主要是因为 RGB565 共占用 2 个字节， 两个字节的顺序不同造成的，把第二张图从中间分隔成两份，右边移到左边，就变成了第一种的排列方式了。</p><h3 id="2-推荐的能够跟随学习的（待补充）"><a href="#2-推荐的能够跟随学习的（待补充）" class="headerlink" title="2.推荐的能够跟随学习的（待补充）"></a>2.推荐的能够跟随学习的（待补充）</h3><h4 id="2-1-爱上半导体"><a href="#2-1-爱上半导体" class="headerlink" title="2.1 爱上半导体"></a>2.1 爱上半导体</h4><p>B站UP主，一个比较全面的up，讲的理论也较多，我（Trace）大多看里面的关于元器件的知识，植物大战僵尸的BGM很有辨识度。</p><h4 id="2-2-JT硬件乐趣"><a href="#2-2-JT硬件乐趣" class="headerlink" title="2.2 JT硬件乐趣"></a>2.2 JT硬件乐趣</h4><p>B站UP主，讲的比较深，大多是关于PCB绘制的规则以及注意事项等，但是看弹幕以及评论他讲的好像有些争议。</p><h4 id="2-3-TI官网"><a href="#2-3-TI官网" class="headerlink" title="2.3 TI官网"></a>2.3 TI官网</h4><p>TI，德州仪器（Texas Instruments），一家全球化半导体设计与制造企业，凭借 80,000+ 模拟 IC 与嵌入式处理器产品、各类软件以及最大规模的销售和技术支持不断开拓创新。</p><p>我们使用的大多数的电源芯片为TI研制的，同时TI在多个领域也有触及。TI芯片的数据手册十分亲民，甚至会将PCBLayout给出。</p><p>全国大学生电子设计大赛就是由TI公司赞助的，所以在大电赛中会有要求某一赛题必须使用TI的单片机来完成。（但是TI在单片机这方面并不出名）</p><p>TI官网里面有很多资料，其中最完美的当属关于电源的芯片的。</p><h4 id="2-4-唐老师讲电赛"><a href="#2-4-唐老师讲电赛" class="headerlink" title="2.4 唐老师讲电赛"></a>2.4 唐老师讲电赛</h4><p>讲的大多是电赛相关的，涉及面较广，适合大学生学习。但总觉得语速有些慢，且口音有些奇怪(？)。</p><h3 id="3-关于电磁组正入库"><a href="#3-关于电磁组正入库" class="headerlink" title="3.关于电磁组正入库"></a>3.关于电磁组正入库</h3><p>在竞速组别中，电磁组因为其无法使用摄像头来检测斑马线所以只能够通过检测斑马线下埋藏的磁铁来入库。</p><p>通常使用干簧管或者霍尔元件来进行入库。18届电磁组选择的使用霍尔元件来入库，效果不错，相较于干簧管，霍尔元件具有更小的的体积。然而，无论是干簧管还是霍尔元件，都不可避免的要固定在小车上，所以就造成了识别到磁铁时小车就已经走过库了，只能倒车入库，无法正入库的问题，倒车入库相较于正入库要多出1-2s的时间。</p><p>那么有没有一种方法是能够使电磁车直接入库的呢？</p><p>答案是有的，想要正入库，所需要的无疑是提前识别到斑马线或者磁铁的位置，在18届比赛中，本人在比赛中见到了几种正入库的设计，有些是将霍尔检测装置以悬吊、粘贴等方法放置于小车前方，而另一种则是通过<strong>漫反射激光传感器</strong>来提前识别斑马线。此模块禁止直接购买使用，但是却可以自制。</p><p><img src="/.com//个人博客\hexo\blog\themes\vivia\source\images\ima\10.jpg" alt="9ba4b6ac2a7066956277bddd923c8d9"></p><p>因为时间过于仓促，所以在得知此模块能够提前入库时已经来不及制作，且此模块原理图难以寻找，所以在此处提到，是否要增加取决于后来者个人。</p><p>进阶学习相关资料：</p><p>电子档书籍，链接：链接：<a href="https://pan.baidu.com/s/1kD5TTjCaY6X51wD6eUEwHg">https://pan.baidu.com/s/1kD5TTjCaY6X51wD6eUEwHg</a><br>        提取码：grzh </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;此篇文章由Trace以及其队友郑鹤联合整理编写。其中，硬件部分由Trace整理编写，软件相关则由郑鹤负责。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.gsimg.top/2024/04/21/10f2mjx.jpg&quot; alt=&quot;d3</summary>
      
    
    
    
    
    <category term="硬件知识" scheme="http://example.com/tags/%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
